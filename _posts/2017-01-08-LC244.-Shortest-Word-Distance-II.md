---
layout: post
title: LC244. Shortest Word Distance II
subtitle: Follow up of Shortest Word Distance.
date: 2017-01-08
categories: Leetcode
tags: [Design, Hashmap]
catalog: true
---

### LC244. Shortest Word Distance II

This is aÂ **follow up**Â ofÂ [Shortest Word Distance](https://leetcode.com/problems/shortest-word-distance). The only difference is now you are given the list of words and your method will be calledÂ *repeatedly*Â many times with different parameters. How would you optimize it?

Design a class which receives a list of words in the constructor, and implements a method that takes two wordsÂ *word1*Â andÂ *word2*Â and return the shortest distance between these two words in the list.

For example,
Assume that words =Â `["practice", "makes", "perfect", "coding", "makes"]`.

GivenÂ *word1*Â =Â `â€œcodingâ€`,Â *word2*Â =Â `â€œpracticeâ€`, return 3.
GivenÂ *word1*Â =Â `"makes"`,Â *word2*Â =Â `"coding"`, return 1.

**Note:**
You may assume thatÂ *word1*Â **does not equal to**Â *word2*, andÂ *word1*Â andÂ *word2*Â are both in the list.

æ±‚ä¸€ä¸ªarrayä¸­ä¸¤ä¸ªå…ƒç´ çš„æœ€çŸ­è·ç¦»æ˜¯å¤šå°‘ï¼Œé‚£å°±ç”¨hashmapå­˜å°±è¡Œã€‚

##### TreeSet solutionï¼š

TreeSetçš„addåº”è¯¥æ˜¯O(lgn)çš„ï¼Œä½†æ˜¯å…·æœ‰higherå’Œlowerå‡½æ•°ï¼Œåº”è¯¥ä¹Ÿæ˜¯O(lgn)çš„ï¼Œä¼šæ¯”éå†ä¸¤ä¸ªArrayListæ›´å¿«ä¸€äº›ã€‚è¿™æ ·shorestçš„å¤æ‚åº¦åº”è¯¥æ˜¯O(mlgn) (m < n).

```java
public class WordDistance {

    String[] word;
    Map<String, TreeSet<Integer>> map;
    public WordDistance(String[] words) {
        word = words;
        map = new HashMap<>();
        for(int i = 0; i < words.length; i++){
            if(!map.containsKey(words[i])){
                map.put(words[i], new TreeSet<Integer>());
            }
            map.get(words[i]).add(i);
        } // for
    }

    public int shortest(String word1, String word2) {
        TreeSet<Integer> set1 = map.get(word1);
        TreeSet<Integer> set2 = map.get(word2);
        if(set1.size() > set2.size()){
            return shortest(word2, word1);
        }
        int res = word.length;
        for(Integer in: set1){
            Integer hi = set2.higher(in);
            if(hi != null){
                res = Math.min(hi.intValue() - in.intValue(), res);
            }
            Integer lo = set2.lower(in);
            if(lo != null){
                res = Math.min(in.intValue() - lo.intValue(), res);
            }
        } // for
        return res;
    }
}

// Your WordDistance object will be instantiated and called as such:
// WordDistance wordDistance = new WordDistance(words);
// wordDistance.shortest("word1", "word2");
// wordDistance.shortest("anotherWord1", "anotherWord2");
```

##### Another better solution:

> [Java HashMap](https://discuss.leetcode.com/topic/20643/java-solution-using-hashmap/2)

```java
public class WordDistance {

private Map<String, List<Integer>> map;

public WordDistance(String[] words) {
    map = new HashMap<String, List<Integer>>();
    for(int i = 0; i < words.length; i++) {
        String w = words[i];
        if(map.containsKey(w)) {
            map.get(w).add(i);
        } else {
            List<Integer> list = new ArrayList<Integer>();
            list.add(i);
            map.put(w, list);
        }
    }
}

public int shortest(String word1, String word2) {
    List<Integer> list1 = map.get(word1);
    List<Integer> list2 = map.get(word2);
    int ret = Integer.MAX_VALUE;
    for(int i = 0, j = 0; i < list1.size() && j < list2.size(); ) {
        int index1 = list1.get(i), index2 = list2.get(j);
        if(index1 < index2) {
            ret = Math.min(ret, index2 - index1);
            i++;
        } else {
            ret = Math.min(ret, index1 - index2);
            j++;
        }
    }
    return ret;
}
}
```

Discussçš„è¿™ä¸ªç­”æ¡ˆï¼Œéå†çš„æ—¶å€™list1, list2æ˜¯æ’åºçš„arrayï¼Œåªéœ€è¦O(m + n)å°±å¯ä»¥æ‰¾åˆ°æœ€å°çš„å·®å€¼ï¼Œè€Œä¸éœ€è¦O(mn). 

ğŸŒ°

> word1Indexes = 10,50,70
> word2Indexes = 22,30,60,71
>
> The left over portion of the larger length array need to be again checked. In the above cases, the min diff between 70 and 71 will be left out.
>
> Also the code can be optimized further by binary search;
> Consider the following arrays;
> 1,2,3,4,7,9,10
> 6,8,11,12
>
> after the first iteration, diff between word1 and word2 = 6 - 1 = 5
>
> Hence in array1, no point in looking at values 2,3,4 one by one
>
> Instead use binary search to find the value in array1 that is larger than the difference of 5 (which is 7).



