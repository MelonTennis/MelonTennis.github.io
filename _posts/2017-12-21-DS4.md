---
layout: post
title: Distributed System IV
subtitle: 15640 DS4 - Distributed Mutex & Concurrency
date: 2017-12-21
categories: Note
tags: [DS, 15640]
catalog: true
---

## Distributed System IV

这一篇讲分布式系统下的互斥锁和同步控制。介绍了一些同步算法和2PC。Lamport和2PC是重点介绍的内容，在实际应用中也很广泛。

### Distributed Mutual Exclusion

介绍了许多算法。

首先Mutual Exclusion Requirements:

* Correctness/Safety: At most one process holds the lock/enter C.S. at a time
* Fairness: Any process that makes a request must be granted lock

Distributed Requirements (focus on 1-3):

* Low message overhead
* No bottlenecks
* Tolerate out-of-order messages
* Allow processes to join protocol or to drop out
* Tolerate failed processes
* Tolerate dropped messages

袭来一大波Mutual Exclusion算法。

#### Centralized Mutual Exclusion

| If server available send Grant to i      | If server unavailable add i to Q         | If Q not empty, remove i and send Grant  |
| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| <img src="https://raw.githubusercontent.com/YijiaJin/Plot/master/central1.png" style="zoom:40%"> | <img src="https://raw.githubusercontent.com/YijiaJin/Plot/master/central2.png" style="zoom:40%"> | <img src="https://raw.githubusercontent.com/YijiaJin/Plot/master/central3.png" style="zoom:40%"> |
| Clinet sends require to coordinator and wait for reply | -----------------------------------      | Client send release to coordinator       |

* Correctness: safe, fairness depends on queuing policy
* Performance: 3 messages/cycle (request, grant, release)
* Coordinator bottleneck

#### Bully Leader Election

* The Bully Algorithm
  * P sends an ELECTION message to all processes withhigher numbers.
  * If no one responds, P wins the election and becomescoordinator.
  * If one of the higher-ups answers, it takes over. P’s jobis done.

- Goal: anyone can trigger election whichautomatically determines a unique new leader

  <img src="https://raw.githubusercontent.com/YijiaJin/Plot/master/bully1.png" style="zoom:45%">

​				
<img src="https://raw.githubusercontent.com/YijiaJin/Plot/master/bully2.png" style="zoom:55%">

#### Decentralized Mutual Exclusion

Assume that there are n coordinators

* Get a majority vote from m > n/2 coordinators
* Reply immediately with GRANT or DENY

Problems: node failure, starvation(less than majority votes)

| Request                                  | Reply                                    |
| ---------------------------------------- | ---------------------------------------- |
| <img src="https://raw.githubusercontent.com/YijiaJin/Plot/master/decentral1.png" style="zoom:40%"> | <img src="https://raw.githubusercontent.com/YijiaJin/Plot/master/decentral2.png" style="zoom:40%"> |

#### Totally-Ordered Multicast

Assumption: all messages sent by one sender are received in the order they were sent and that no messages are lost.

Process:

* Multicast messages + local timestamp-ordered queue
* Multicasts an ACK to all other processes
* Process only if *both* at queue head and ACK’ed


<img src="https://raw.githubusercontent.com/YijiaJin/Plot/master/totally.png" style="zoom:50%">				
​			

- Key point from Lamport: the timestamp of the received message is lower than the timestamp of the ACK.
- All processes will eventually have the same copy of the local queue consistent global ordering.		

#### Lamport Mutual Exclusion

被DS白日梦破碎击垮。已经开始无脑写了。

* Based on Lamport TO-multicast
* ACK only to requestor
* Release after finished

<img src="https://raw.githubusercontent.com/YijiaJin/Plot/master/lampotmutex.png" style="zoom:50%">

* For single process send: n-1 request, n-1 reply, n-1 release

#### 	Ricart & Agrawala Mutex

* Relies on Lamport totally ordered clocks.

- When node i wants to enter C.S., it sends time-stamped request to all other nodes. These othernodes reply (eventually). When i receives n-1 replies, then can enter C.S.
- Trick: Node j having earlier request doesn't replyto i until after it has completed its C.S.

<img src="https://raw.githubusercontent.com/YijiaJin/Plot/master/ricard.png" style="zoom:50%">

* Deadlock free, starvation free
* Each cycle involves 2(n-1) messages

#### Token Ring Algorithm

- Organize the processes involved into a logical ring
- One token at any timepassed from node to node along ring
- Only one process can hold token and pass ring at most once
- Each cycle requires 1~infinity messages, latency between 1&n-1
- Problem: loss token				

#### Compare & Summary

<img src="https://raw.githubusercontent.com/YijiaJin/Plot/master/compare.png" style="zoom:50%">

* Lamport algorithm demonstrates how distributedprocesses can maintain consistent replicas of adata structure. 
* Ricart & Agrawala's algorithm demonstrate utilityof logical clocks. 
* Centralized & ring based algorithms have muchlower message counts. 
* None of these algorithms can tolerate failedprocesses or dropped messages.

​		
​					
​			
​		
​	

​		