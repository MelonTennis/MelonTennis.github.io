---
layout: post
title: LC469. Convex Polygon
subtitle: Decide a convex polygon
date: 2017-01-02
categories: Leetcode
tags: [Math]
catalog: true
---

### LC469. Convex Polygon

Given a list of points that form a polygon when joined sequentially, find if this polygon is convexÂ [(Convex polygon definition)](https://en.wikipedia.org/wiki/Convex_polygon).

**Example 1:**

```
[[0,0],[0,1],[1,1],[1,0]]

Answer: True
```

**Example 2:**

```
[[0,0],[0,10],[10,10],[10,0],[5,5]]

Answer: False
```

æ•°å­¦é—®é¢˜ï¼Œå‡¸å¤šè¾¹å½¢çš„è¯ï¼Œæˆ‘çŸ¥é“æ˜¯æ‰€æœ‰çš„ç‚¹éƒ½åœ¨ä»»å–ä¸€æ¡å˜çš„ä¸€ä¾§ï¼Œä¹Ÿå¯ä»¥è¯´æ˜¯æ¯ä¸ªå¤¹è§’éƒ½åœ¨[0, 180]åº¦ã€‚ğŸ‘‡åˆ†æå†™çš„æŒºå¥½çš„ã€‚

> [Use corner degree](https://discuss.leetcode.com/topic/70643/i-believe-this-time-it-s-far-beyond-my-ability-to-get-a-good-grade-of-the-contest)
>
> [Right hand rule](https://discuss.leetcode.com/topic/70706/beyond-my-knowledge-java-solution-with-in-line-explanation)

æ€»ä¹‹å¯¹æ¯ç›¸é‚»ä¸¤è¾¹è¿›è¡Œåˆ¤æ–­ï¼Œ æ‰€æœ‰çš„å¤¹è§’ç¬¦åˆåŒä¸€ä¸ªè¦æ±‚å°±å¥½ã€‚

```java
public class Solution {
    public boolean isConvex(List<List<Integer>> points) {
        // for a series of points, calculate crossProduct of each two edges
        // depends on its order, they should be the all > 0 or < 0
        if(points == null || points.size() == 0) return false;
        boolean positive = false, negative = false;
        int num = points.size();
        for(int i = 0; i < num; i++){
            // if i = 0 or i = num - 1
            List<Integer> point = points.get(i);
            List<Integer> next = points.get((i + 1)%num);
            List<Integer> pre = points.get((i - 1+num)%num);
            int cp = crossProduct(pre, point, next);
            if(cp > 0) positive = true;
            if(cp < 0) negative = true;
            if(positive && negative)    return false;
        }
        return true;
    } // isConvex
    
    private int crossProduct(List<Integer> pre, List<Integer> cur, List<Integer> next){
        return (cur.get(0) - pre.get(0))*(cur.get(1) - next.get(1)) - (cur.get(1) - pre.get(1))*(cur.get(0) - next.get(0));
    } // crossProduct
}
```

O(n). 