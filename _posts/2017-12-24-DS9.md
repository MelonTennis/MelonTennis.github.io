---
layout: post
title: Distributed System IX
subtitle: 15640 DS9 - Hashing & P2P/Blockchains
date: 2017-12-24
categories: Note
tags: [DS, 15640]
catalog: true
---

## Distributed System IX

è¿˜åœ¨å»å¾€ä¸¹ä½›çš„é£æœºä¸Šçå†™ï¼Œè¶Šå†™è¶Šå·®ã€‚æ—¥å¸¸æ€€ç–‘è‡ªå·±æ˜¯åƒåœ¾ã€‚

### Hashing

...å…­å¤©å å‡æœŸå›å®¶æ‘¸é±¼ğŸŸ è¿˜ä»¥ä¸ºåœ¨é£æœºå’Œé«˜é“ä¸Šèƒ½éƒ½å†™å®Œå‘¢ å¯æˆ‘å¤ªå›°äº†è¿˜æŠŠå›´å·¾ä¸¢äº† å“­æ³£à²¥_à²¥

å½“å‰ä¸»è¦ä¸¤ç§Hashingæ¯”è¾ƒæµè¡Œï¼Œconsistent hashingå’Œcontent-based hashing.

#### Conventional Hash

bucket  = hash(item)/num_buckets

convenitonal hashingå¯ä»¥å°†itemå¹³å‡åˆ†é…åœ¨serverä¸Šï¼Œä½†æ˜¯å½“item/serverçš„è¿›è¡Œæ”¹å˜æ—¶ä¼šå¯¼è‡´å¤§é‡çš„è¿ç§»ã€‚

å‡å°‘ä¸€ä¸ªserverï¼Œéœ€è¦è¿ç§»1/2çš„itemã€‚

#### Consistent Hash

Desired Features:

* Balanced - in any one view, load is equal across buckets
* Smoothness â€“ little impact on hash bucket contents when buckets are added/removed
* Spread â€“ small set of hash buckets that may hold an object regardless of views
* Load â€“ across all views # of objects assigned to hash bucket is small

Main idea: 

* map both keys and nodes to the same (metric) identifier space 
* find a â€œruleâ€ how to assign keys to nodes

<img src="https://raw.githubusercontent.com/YijiaJin/Plot/master/ring.png" style="zoom:50%">

Consistent hashingåˆ©ç”¨SHA-1åˆ†åˆ«å“ˆå¸Œkeyå’Œnodeï¼Œå°†keyå­˜åœ¨å“ˆå¸Œå€¼ä¸å°äºå…¶å“ˆå¸Œçš„ä¸‹ä¸€ä¸ªnodeé‡Œã€‚ä¸ºäº†ä¿è¯æ¯ä¸ªnodeçš„å­˜å‚¨keyæ•°ç›®ä¸€è‡´ï¼Œåˆ©ç”¨virtual nodeå°†æ‰€æœ‰çš„nodeåˆ†å¸ƒåœ¨ringä¸Šï¼Œä¿è¯åœ¨crashæ—¶å½“å‰nodeçš„keyä¸ä¼šå…¨éƒ¨è¿ç§»åˆ°ä¸‹ä¸€ä¸ªnodeä¸Šé¢ã€‚

Propertiesï¼š

* Ring-based construction using hash of key and node

* Smoothnessï¼š addition of bucket does not cause much movement

  between existing buckets

* Load: for N nodes and K keys, with high probability, each node holds at most (1+Îµï¥ï¥)K/N keys

* Spread: small set of buckets that lie near object

* Balance: no bucket is responsible for large number of objects

#### Hashing for naming

å®Œå…¨æ²¡æœ‰å°è±¡ï¼Œéš¾é“æ˜¯å› ä¸ºæ¬£èµDanielçš„ç¾é¢œè€Œèµ°ç¥äº†å—ï¼Ÿ

å¤§æ¦‚è®²Hashçš„åº”ç”¨ã€‚ä¸€ä¸ªæ˜¯åœ¨Storage Systemä¸­ï¼ŒæŠŠå†…å®¹hashå¯ä»¥é¿å…å­˜å‚¨ç›¸åŒçš„æ•°æ®ï¼Œå•Šdropboxçš„æ–¹æ³•å–½ã€‚ç„¶ååˆ©ç”¨hashæ¥å‘½åï¼ŒåŒæ ·å¯ä»¥é¿å…å­˜å‚¨ä¸€ä¸ªitemä¸¤æ¬¡ã€‚åˆ©ç”¨hashä¹Ÿå¯ä»¥æ£€éªŒä»ä½ç½®æºä¸‹è½½çš„æ–‡ä»¶ã€‚

**Desirable properities of Hashes**

* Compression: Maps a variable-length length input to a fixed-length output
* Ease of computation: A relative metric...
* Pre-image resistance: For all outputs, computationally infeasible to find input that produces output.
* 2nd pre-image resistance: For all inputs, computationally infeasible to find second input that produces same output as a given input.
* collision resistance: For all outputs, computationally infeasible to find two inputs that produce the same output.

### P2P System

P2P, ä¸Šè¯¾èµ°ç¥OHæ‰¾å¸…åŠ©æ•™Felipeè®¨è®ºäº†ä¸€æ³¢ç»ˆäºç†è§£äº†ã€‚ä¹‹å‰è¯¾ä¸Šè®¨è®ºçš„åˆ†å¸ƒå¼ç³»ç»Ÿå¤§å¤šæ˜¯ç”±ä¸€ä¸ªmaster serverå’Œè®¸å¤šparticipantsç»„æˆçš„æ¨¡å¼ï¼Œåˆ©ç”¨masterå’Œparticipantsçš„é€šä¿¡æ¥å®Œæˆæ•°æ®çš„äº¤æ¢å’Œä¿è¯ä¸€è‡´æ€§ã€‚ä½†æ˜¯å½“ç³»ç»Ÿçš„è§„æ¨¡æ¯”è¾ƒå¤§æ—¶masterä¼šæˆä¸ºç³»ç»Ÿçš„bottleneckå½±å“ç³»ç»Ÿæ•´ä½“çš„æ€§èƒ½ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹å¼•å…¥äº†P2Pç³»ç»Ÿçš„æ¦‚å¿µï¼Œå¯¹äºP2Pç³»ç»Ÿï¼Œæ‰€æœ‰çš„peersè¢«è§†ä¸ºå¹³ç­‰çš„ï¼Œèƒ½å¤Ÿå’Œneighboursè¿›è¡Œé€šä¿¡ã€‚

#### P2P Networks

* Typically each member stores/provides access to content
* Basically a replication system for files
  * tradeoff between possible location of files and searching difficulty
* Challenge 1: searching / lookup (files can be anywhere)
* Challenge 2: fairness (everyone gets rightful share and everyone contributes)
  * Contribution to P2P system must be incentivized.
* Challenge 3: trust (downloading files from unknown sources)

#### Efficient lookups

|         | Centralized                              | Decentralized                            | BitTorrent                               | DHT                                      |
| ------- | ---------------------------------------- | ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| Example | Napster                                  | Gnutella                                 | **BitTorrent**                           | use Chord                                |
| Join    | on startup, clinet contacts central server | on startup, client contacts a few other nodes, becomes neighbours | contact centralized â€œtrackerâ€ server, get a list of peers | on startup, contact a â€œbootstrapâ€ node and get a node id |
| Publish | reports list of files to central server  | no need                                  | run a tracker server                     | route publication for file id toward a close node id |
| Search  | query the server, O(1)                   | ask neighbors continuouslly until found and reply to sender, O(n) | out-of-band (e.g, use Google), O(???)    | route a query for file id toward a close node id,  O(lgN) |
| Fetch   | get the file directly from peer          | get the file directly from peer          | download chunks of the file from your peers, upload chunks you have to them. | fetch from where query stops/use IP routing to get X |
| Pros    | simple, search O(1), cotrollable         | decentralized, search cost distributed   | works reasonably well in practice,  efficient out of band search mechanism | decentralized, guaranteed lookup, O(lgN) per node state and search scope |
| Cons    | server maintain O(N) state and does all processing, single  point of failu | search scope O(n),  nodes leave often network unstable, does not search every node causing re-issue | central tracker server needed to bootstrap swarm, tracker needs to maintain peer list for every file | supporting non-exact match search is hard |

DHT uses consistent hashing.  Chordçš„æŸ¥æ‰¾é‡ç‚¹ã€‚Consistent hashingä¿è¯äº†æœ‰Mä¸ªnodeNä¸ªkeyæƒ…å†µä¸‹å½“æœ‰keyå‘ç”Ÿæ”¹å˜æ—¶ï¼Œéœ€è¦ç§»åŠ¨çš„keyå¤§çº¦N/Mä¸ªï¼Œè€Œä¸æ˜¯convenient hashingçš„N/2ä¸ªã€‚ä½†æ˜¯å¯¹äºP2Pï¼ŒæŸ¥æ‰¾ä»éœ€è¦è¿­ä»£åœ°å¯¹é‚»å±…è¿›è¡ŒæŸ¥æ‰¾ï¼ŒO(N)æ—¶é—´å¤æ‚åº¦ã€‚ä¸ºäº†ä¼˜åŒ–æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦ï¼Œå°±åœ¨æ¯ä¸ªnodeå­˜finger tableï¼Œå°±æ¯æ¬¡éœ€è¦ä¼˜åŒ–æ—¶é—´éƒ½cacheå§ã€‚æ¯ä¸ªtableæ‰€å ç”¨ç©ºé—´O(lgN)ï¼ŒæŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦å˜ä¸ºO(lgN)ã€‚

<img src="https://raw.githubusercontent.com/YijiaJin/Plot/master/chord.png" style="zoom:50%">

æ¯ä¸ªnodeçš„finger tableå…·æœ‰mä¸ªentryï¼Œè¿™é‡Œå‡è®¾2^m = N. å¯¹æ¯ä¸ªentry number  iè®¡ç®—id + 2^iï¼Œsuccessoræ˜¯è¿™ä¸ªç»“æœåº”è¯¥å­˜å‚¨çš„node numberã€‚è¿™æ ·æ¯ä¸ªfinger tableçš„size = lgNï¼ŒæŸ¥æ‰¾æ—¶é¦–å…ˆåœ¨æœ¬åœ°è¿›è¡ŒæŸ¥æ‰¾ï¼Œå¦åˆ™åˆ°finger tableçš„successorè¡¨ä¸­ç¬¬ä¸€ä¸ª>=keyçš„nodeè¿›è¡ŒæŸ¥æ‰¾ï¼Œè¿™æ ·æŸ¥æ‰¾æ—¶é—´O(lgN)ã€‚

#### Fairness

å¦‚ä½•ä¿è¯æ¯ä¸ªpeerséƒ½ä¼šä¸Šä¼ æ–‡ä»¶å¹¶ä¸”ä¿è¯æ–‡ä»¶æ—¶æ­£ç¡®çš„ã€‚

* Freeloader problem 
  * All peers must contribute 
  * How to prevent peers leeching resources
* Efficiency 
  * Single peer is bottleneck => similar to bottleneck in a centralized approach 
  * Load balancing across peers

**BitTorrent sharing strategy**

* Employ â€œTit-for-tatâ€ sharing strategy 
  * A is downloading from some other people 
    * A will let the fastest N of those download from him 
  * Be optimistic: occasionally let freeloaders download 
* Distribute chunks across peers 
  * When a new file is seeded, peers download random chunks 
  * Results in load balancing as different peers have different subset of chunks

#### Trust

BitTorrent:

* Check that the file is correct
* Check that the chunk downloaded from a peer is valid

### Blockchains

Motivation: decentralized transactions

Key problem: double spending -> someone track all transactions

Solution: Ledger: every transactions made

Blockchain consensus:

Solution: Blockchain Consensus

* broadcast new transactions 
* each member collects transactions into a block 
* each member seeks proof-of-work for its block
  * proof-of-work (PoW): solve a computationally hard problem
* member who finds PoW broadcasts block+PoW 
* other member check block, seek next PoW 
* consensus over time


~~piazza17F Disributed Systemå·²ç»æ²¡æœ‰äº† æœ¬æ¥æ‰“ç®—æŠŠDanielçš„ç§‘æ™®è´´ä¸Šçš„à²¥_à²¥â€¦~~ 18å¤©å: æ‰¾åˆ°äº†...

> Blockchain and BitCoin Q&A
>
> Â 
>
> 1) Â When is a transaction committed?
>
> Â 
>
> Blockchain miners/peers can include transactions in any order they chose (or even exclude transactions). Each transaction includes a transaction fee it is willing to pay. So in practice, miners includes those with high transaction fees with higher priority.
>
> A transaction is committed only once it is included in a block and there are X successive blocks also included in the blockchain.
>
> Â 
>
> If a miner receives two valid blocks, A and B, with the same parent, it chooses one of the two blocks and continues mining the next block. As soon as there is a success for A, the miner will switch over working on this branch because it is the longest one. Being the longest, the A branch has the highest likelihood of continuing to be part of the blockchain.
>
> Â 
>
> As a consequence, BitCoin clients keep both tips of a fork until one exceeds the other by X.
>
> Â 
>
> (A typical value of X is 4.)
>
> 2) Why do we need to adjust the mining difficulty?
>
> Â 
>
> If too many blocks are successfully mined in a short period of time, then there might be many collisions. So, the network tries to keep the number of blocks mined per time interval constant (BitCoing: 2016 blocks per two weeks).
>
> 3) How do we adjust the mining difficulty?
>
> Â 
>
> By changing the difficulty K of the hashing puzzle: picking a nonce such that the hash value has K leading zeros (or, equivalently, the hash value as an integer is less than 2^(256-K)).
>
> Â 
>
> The nonce is a 32-bit field. By picking a different nonce, the hash changes. Mining means randomly trying nonces until a matching hash has been found (due to the cryptographic properties of SHA, even sequentially trying nonces is basically random).
>
> 4) If a new transaction arrives at a miner, does the miner try to include the transaction into the block currently being mined?
>
> Â 
>
> BitCoin has a block limit of 1MB. So, if the block is full (and the transaction has a low fee) the new transaction will be ignored for the moment.
>
> Â 
>
> If the block is not full yet, the miner probably includes the transaction (to get the fee). Due to the mining (search for nonces) being purely random, this does not lead to lost effort.
>
> Â 
>
> 5) Is there a guarantee that trying out all nonces actually solves the puzzle?
>
> Â 
>
> No, there is no such guarantee. It is in the interest of the miner to add randomness (e.g., add or switch out transactions).
>
> 6) Why is there a limit on the total supply of BitCoins?
>
> Â 
>
> For purely economic reasons. Anything of which there is an infinite amount has no value.
>
> However, BitCoins are infinitely divisible.
>
> 7) How is the total BitCoin supply controlled?
>
> Â 
>
> The number of bitcoins generated per block decreases geometrically. Starting with 50 BitCoins per block initially, the reward for mining is reduced to 50% every 210,000 blocks.
>
> Â 
>
> 8) Why should the miners continue mining if the reward becomes very small?
>
> Â 
>
> As people want to use BitCoin to make transactions, they will incentivize miners by raising their transaction fees (which go to the miner who solved the block included that transaction).