---
layout: post
title: Distributed System IX
subtitle: 15640 DS9 - Naming/Hashing & P2P/Blockchains
date: 2017-12-24
categories: Note
tags: [DS, 15640]
catalog: true
---

## Distributed System IX

还在去往丹佛的飞机上瞎写，越写越差。日常怀疑自己是垃圾。

### Naming & Hashing

课件16没有下载

### P2P System

P2P, 上课走神OH找帅助教Felipe讨论了一波终于理解了。之前课上讨论的分布式系统大多是由一个master server和许多participants组成的模式，利用master和participants的通信来完成数据的交换和保证一致性。但是当系统的规模比较大时master会成为系统的bottleneck影响系统整体的性能。在这种情况下引入了P2P系统的概念，对于P2P系统，所有的peers被视为平等的，能够和neighbours进行通信。

#### P2P Networks

* Typically each member stores/provides access to content
* Basically a replication system for files
  * tradeoff between possible location of files and searching difficulty
* Challenge 1: searching / lookup (files can be anywhere)
* Challenge 2: fairness (everyone gets rightful share and everyone contributes)
  * Contribution to P2P system must be incentivized.
* Challenge 3: trust (downloading files from unknown sources)

#### Efficient lookups

|         | Centralized                              | Decentralized                            | BitTorrent                               | DHT                                      |
| ------- | ---------------------------------------- | ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| Example | Napster                                  | Gnutella                                 | **BitTorrent**                           | use Chord                                |
| Join    | on startup, clinet contacts central server | on startup, client contacts a few other nodes, becomes neighbours | contact centralized “tracker” server, get a list of peers | on startup, contact a “bootstrap” node and get a node id |
| Publish | reports list of files to central server  | no need                                  | run a tracker server                     | route publication for file id toward a close node id |
| Search  | query the server, O(1)                   | ask neighbors continuouslly until found and reply to sender, O(n) | out-of-band (e.g, use Google), O(???)    | route a query for file id toward a close node id,  O(lgN) |
| Fetch   | get the file directly from peer          | get the file directly from peer          | download chunks of the file from your peers, upload chunks you have to them. | fetch from where query stops/use IP routing to get X |
| Pros    | simple, search O(1), cotrollable         | decentralized, search cost distributed   | works reasonably well in practice,  efficient out of band search mechanism | decentralized, guaranteed lookup, O(lgN) per node state and search scope |
| Cons    | server maintain O(N) state and does all processing, single  point of failu | search scope O(n),  nodes leave often network unstable, does not search every node causing re-issue | central tracker server needed to bootstrap swarm, tracker needs to maintain peer list for every file | supporting non-exact match search is hard |

DHT uses consistent hashing.  Chord的查找重点。Consistent hashing保证了有M个nodeN个key情况下当有key发生改变时，需要移动的key大约N/M个，而不是convenient hashing的N/2个。但是对于P2P，查找仍需要迭代地对邻居进行查找，O(N)时间复杂度。为了优化查找的时间复杂度，就在每个node存finger table，就每次需要优化时间都cache吧。每个table所占用空间O(lgN)，查找的时间复杂度变为O(lgN)。

<img src="https://raw.githubusercontent.com/YijiaJin/Plot/master/chord.png" style="zoom:50%">

每个node的finger table具有m个entry，这里假设2^m = N. 对每个entry number  i计算id + 2^i，successor是这个结果应该存储的node number。这样每个finger table的size = lgN，查找时首先在本地进行查找，否则到finger table的successor表中第一个>=key的node进行查找，这样查找时间O(lgN)。

#### Fairness

如何保证每个peers都会上传文件并且保证文件时正确的。

* Freeloader problem 
  * All peers must contribute 
  * How to prevent peers leeching resources
* Efficiency 
  * Single peer is bottleneck => similar to bottleneck in a centralized approach 
  * Load balancing across peers

**BitTorrent sharing strategy**

* Employ “Tit-for-tat” sharing strategy 
  * A is downloading from some other people 
    * A will let the fastest N of those download from him 
  * Be optimistic: occasionally let freeloaders download 
* Distribute chunks across peers 
  * When a new file is seeded, peers download random chunks 
  * Results in load balancing as different peers have different subset of chunks

#### Trust

BitTorrent:

* Check that the file is correct
* Check that the chunk downloaded from a peer is valid

### Blockchains

Motivation: decentralized transactions

Key problem: double spending -> someone track all transactions

Solution: Ledger: every transactions made

Blockchain consensus:

Solution: Blockchain Consensus

* broadcast new transactions 
* each member collects transactions into a block 
* each member seeks proof-of-work for its block
  * proof-of-work (PoW): solve a computationally hard problem
* member who finds PoW broadcasts block+PoW 
* other member check block, seek next PoW 
* consensus over time


piazza补充一些Daniel发的资料




