---
layout: post
title: LC300. Longest Increasing Subsequence
subtitle: not necessarily continuous
date: 2016-12-27
categories: Leetcode
tags: [DP, BinarySearch]
catalog: true
---

#### Question

Given an unsorted array of integers, find the length of longest increasing subsequence.

For example,
GivenÂ `[10, 9, 2, 5, 3, 7, 101, 18]`,
The longest increasing subsequence isÂ `[2, 3, 7, 101]`, therefore the length isÂ `4`. Note that there may be more than one LIS combination, it is only necessary for you to return the length.

Your algorithm should run in O(*n2*) complexity.

**Follow up:**Â Could you improve it to O(*n*Â logÂ *n*) time complexity?

1. O(n^2):

res[i]ä»£è¡¨iä¸‹æ ‡ç»“å°¾çš„æœ€é•¿LISã€‚å¯¹äºres[i],å¦‚æœnum[i] > num[j] (j < i), res[i] ä¸ºæ»¡è¶³æ­¤æ¡ä»¶çš„res[j] + 1, æ¯ä¸€æ­¥å–æœ€ä¼˜ã€‚

```java
public class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) {
            return 0;
        }
        int[] res = new int[nums.length+1];
        res[0] = 1;
        int index = 1;
        for(int i = 1; i < nums.length; i++) {
            int max = 1;
            for(int j = 0; j < i; j++) {
                if(nums[i] > nums[j]) {
                    max = Math.max(max, res[j]+1);
                }
            }
            res[i] = max;
            index = Math.max(index, res[i]);
        } // for i
        return index;
    } // lengthOfInt
}
```

2. O(nlgn):

>  [ä½å¡ç™¾äº‹å¤§ç¥çš„è§£æ³•](https://discuss.leetcode.com/topic/28738/java-python-binary-search-o-nlogn-time-with-explanation/11)

 å¯¹iå±äº(1, nums.length], tailsä»£è¡¨é•¿åº¦ä¸ºiçš„LISæœ€å°çš„æœ«å°¾ã€‚å¯¹æ¯ä¸ªnumäºŒåˆ†æŸ¥æ‰¾æ›´æ–°tailsçš„ä½ç½®ï¼Œå¦‚æœnumå¤§äºå­˜åœ¨äºtailsçš„æ‰€æœ‰æœ«å°¾å€¼åˆ™size++ã€‚~~æ€ä¹ˆä»€ä¹ˆéƒ½ä¼šğŸ™„~~

```java
public class Solution {
    // tails[] means for each length = i LIS, the min tail of it
    // for each num, binary search in tails[]
    // if it is larger than tails[end], size++
    // else in tails, find the right update place
    // O(nlgn)
    public int lengthOfLIS(int[] nums) {
        int tails[] = new int[nums.length];
        int size = 0; 
        for(int num: nums){
            int begin = 0, end = size; 
            // find m when tail[m-1] < mid < tail[m]
            while(begin < end){
                int mid = (begin + end)/2;
                if(tails[mid] < num){
                    begin = mid + 1;
                }else{
                    end = mid;
                }
            }
            tails[begin] = num;
            if(begin == size)   size++;
        }
        return size;
    }
}
```

