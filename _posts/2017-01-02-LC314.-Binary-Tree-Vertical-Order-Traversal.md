---
layout: post
title: LC314. Binary Tree Vertical Order Traversal
subtitle: Left to right vertically traversal.
date: 2017-01-02
categories: Leetcode
tags: [Hashmap]
catalog: true
---

###  LC314. Binary Tree Vertical Order Traversal

Given a binary tree, return theÂ *vertical order*Â traversal of its nodes' values. (ie, from top to bottom, column by column). If two nodes are in the same row and column, the order should be fromÂ **left to right**.

é¢˜ç›®è¦æ±‚ä»å·¦åˆ°å³ï¼Œä»ä¸Šåˆ°ä¸‹ä¸€æ’ä¸€æ’çš„éå†ä¸€æ£µæ ‘ã€‚å””ï¼Œéå†ï¼ŒæŒ‰å±‚çš„è¯bfsç”¨é˜Ÿåˆ—ï¼Œå‰åºä¸­åºååºå¯ä»¥é€’å½’ï¼Œ dfsç”¨æ ˆï¼ŒæŒ‰æ’éå†ï¼ŒHashTable :D

> [5ms Java Solution](https://discuss.leetcode.com/topic/31954/5ms-java-clean-solution)

~~ä¸Šé¢çš„è§£æå†™çš„çœŸå¥½~~ æ€è·¯æ˜¯åˆ©ç”¨queueå…ˆæŒ‰å±‚éå†ï¼Œå› ä¸ºä¸Šå±‚çš„nodeè¦å…ˆè¾“å‡ºã€‚åŒæ—¶æ±‚å‡ºæ¯ä¸€ä¸ªnodeçš„colå€¼ï¼Œå­˜å…¥mapã€‚æœ€åä»mapå‡ºå–å‡ºæ¥ã€‚TreeMapçš„è¯å¯ä»¥ä¿è¯é€’å¢çš„æ’åºï¼Œä½†æ˜¯getæ˜¯lg(n), è€Œhashmapæ˜¯O(1)çš„ï¼Œæˆ‘å¿½ç•¥äº†å…¶å®colsä¸€å®šæ˜¯è¿ç»­çš„æ‰€ä»¥åªè¦è®°å½•max, minå°±å¯ä»¥äº†ã€‚Hashmapè¦å¿«ä¸€äº›ã€‚

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> verticalOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if(root == null)    return res;
        Queue<Integer> cols = new LinkedList<Integer>();
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        Map<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();
        queue.add(root);
        cols.add(0);
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            int col = cols.poll();
            min = Math.min(min, col);
            max = Math.max(max, col);
            if(!map.containsKey(col))   map.put(col, new ArrayList<Integer>());
            map.get(col).add(node.val);
            if(node.left != null)   {
                queue.offer(node.left);
                cols.offer(col - 1);
            }
            if(node.right != null){
                queue.offer(node.right);
                cols.offer(col + 1);
            }
        } // while
        
        for(int i = min; i <= max; i++){
            res.add(map.get(i));
        }
        return res;
    }
}
```

O(n) with hashmap, O(nlgn) with Treemap

> [Java collectoins](http://infotechgems.blogspot.com/2011/11/java-collections-performance-time.html)

ğŸ‘†Java é›†åˆçš„å„ç§æ—¶é—´è¿˜æ˜¯è¦å¤šçœ‹çœ‹ã€‚

~~å…¶å®æˆ‘è¿˜æƒ³å¤šçœ‹çœ‹å°§å°§â¤ï¸â€¦~~